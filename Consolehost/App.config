<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <system.diagnostics>
        <sources>
            <source name="System.ServiceModel.MessageLogging" switchValue="Warning,ActivityTracing">
                <listeners>
                    <add type="System.Diagnostics.DefaultTraceListener" name="Default">
                        <filter type="" />
                    </add>
                    <add name="ServiceModelMessageLoggingListener">
                        <filter type="" />
                    </add>
                </listeners>
            </source>
            <source propagateActivity="true" name="System.ServiceModel" switchValue="Warning,ActivityTracing">
                <listeners>
                    <add type="System.Diagnostics.DefaultTraceListener" name="Default">
                        <filter type="" />
                    </add>
                    <add name="ServiceModelTraceListener">
                        <filter type="" />
                    </add>
                </listeners>
            </source>
        </sources>
        <sharedListeners>
            <add initializeData="c:\users\mscount\documents\visual studio 2012\visual studio 2013\projects\wcfreportingservice\consolehost\app_messages.svclog"
                type="System.Diagnostics.XmlWriterTraceListener, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                name="ServiceModelMessageLoggingListener" traceOutputOptions="Timestamp">
                <filter type="" />
            </add>
            <add initializeData="c:\users\mscount\documents\visual studio 2012\visual studio 2013\projects\wcfreportingservice\consolehost\app_tracelog.svclog"
                type="System.Diagnostics.XmlWriterTraceListener, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                name="ServiceModelTraceListener" traceOutputOptions="Timestamp">
                <filter type="" />
            </add>
        </sharedListeners>
        <trace autoflush="true" />
    </system.diagnostics>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />
    </startup>
  <system.serviceModel>
    <diagnostics>
      <messageLogging logEntireMessage="true" logMalformedMessages="true"
        logMessagesAtTransportLevel="true" />
    </diagnostics>
<!--====Adding this part for File download and message encoding type(messageEncoding="Text" and messageEncoding="Mtom") performance evaluation-->
    <bindings>
      <wsHttpBinding>
        <binding name="wsHttp" messageEncoding="Text" maxReceivedMessageSize="9000000">
          <readerQuotas maxArrayLength="9000000"/>
          <!--====To customize the security mode(message/Transport) for a binding, use mode attribute of security element with in the respective binding--> 
          <!--<security mode="Message">               
            <message clientCredentialType="Windows"/>
            --><!--<message clientCredentialType="UserName"/> --><!--Username Password Validation with SOAPRequest Body as Proxy credentials [Not in Request Header]--><!--
          </security>-->
          
          <!--For Custom Basic Auth - UsernamePassword-->
          <security mode="Message">
            <!--mode="TransportWithMessageCredential">-->
            <message clientCredentialType="UserName"/>
          </security>
        
        <!--====-->
        </binding>
      </wsHttpBinding>

      <!--<wsHttpBinding>
        <binding name="wsHttp" messageEncoding="Text" maxReceivedMessageSize="9000000">
          <readerQuotas maxArrayLength="9000000"/>
        
        </binding>
      </wsHttpBinding>-->

      <!--<basicHttpBinding>
        <binding name="wsHttp" messageEncoding="Text"
          maxReceivedMessageSize="9000000">
          <readerQuotas maxArrayLength="9000000"/>
        </binding>
      </basicHttpBinding>-->

      <!--<netTcpBinding>
        <binding name="wsHttp" messageEncoding="Text"
          maxReceivedMessageSize="9000000">
          <readerQuotas maxArrayLength="9000000"/>
        </binding>
      </netTcpBinding>-->
    </bindings>
<!--=========-->
    <services>
      <service name="WCFReportingservice.Reportingservice" behaviorConfiguration="mexBehaviour">
        <!--<endpoint address="Reportingservice" binding="basicHttpBinding" contract="WCFReportingservice.IPublicReportingservice">
        </endpoint>-->
        <endpoint address="Reportingservice" binding="netTcpBinding" contract="WCFReportingservice.IPrivateReportingservice">
        </endpoint>
        <!--<endpoint address="WCFEmployeeservice" binding="basicHttpBinding" contract="WCFReportingservice.IWCFEmployeeservice">
        </endpoint>-->
        <endpoint address="Reportingservice" binding="wsHttpBinding" contract="WCFReportingservice.IPublicReportingservice">
        </endpoint>
        <endpoint address="WCFEmployeeservice" binding="wsHttpBinding" contract="WCFReportingservice.IWCFEmployeeservice">
        </endpoint>
        <endpoint address="FileHandlingservice" binding="wsHttpBinding" contract="WCFReportingservice.IFileHandlingservice">
        </endpoint>
        <endpoint address="mex" binding="mexHttpBinding" contract="IMetadataExchange" />
        <host>
          <baseAddresses>
            <add baseAddress="http://localhost:8010/" />
            <add baseAddress="net.tcp://localhost:8020"/>
          </baseAddresses>
        </host>
      </service>
    </services>
    
    <behaviors>
      <serviceBehaviors>
        <behavior name="mexBehaviour">
          <serviceMetadata httpGetEnabled="true" />
          <serviceDebug includeExceptionDetailInFaults="true"/>
        <!--By default unhandled exception details are not included in SOAP faults that are propagated to client applications for security reasons. Instead a generic SOAP fault is returned to the client.
For debugging purpose, if you want to include exception details in SOAP faults, enableIncludeExceptionDetailInFaults setting or 
In code using ServiceBehavior attribute
[ServiceBehavior(IncludeExceptionDetailInFaults=true)]-->

          <!--Specify the Custom Authorization policy that will be used and add the policy location-->
              <!--
          <serviceAuthorization principalPermissionMode="Custom">
            <authorizationPolicies>
              <add policyType="WCFReportingservice.AuthorizationPolicy, WCFReportingservice/> // App_Code/Security" />
            </authorizationPolicies>
          </serviceAuthorization>
          -->
              <!--Specify the Custom Authentication policy that will be used and add the policy location-->
            
          <serviceCredentials>
            <userNameAuthentication userNamePasswordValidationMode="Custom"   
                                    customUserNamePasswordValidatorType="WCFReportingservice.UserNamePassValidator,WCFReportingservice"/>
    <!--we also need to install a certificate in our machine and provide the certificate inside <serviceCredentials>.  Create and install a certificate called STSTestCert on my machine.Can also use Pluralsight tool Self-Cert for this purpose-->
          <!--<serviceCertificate findValue="STSTestCert"   storeLocation="LocalMachine"  x509FindType="FindBySubjectName"  storeName="My"/>--> 
          </serviceCredentials>
          
        </behavior>
      </serviceBehaviors>
    </behaviors>
  
  </system.serviceModel>
  <connectionStrings>
    <add name="WCF"
         connectionString="Data Source=SIRAJ;Initial Catalog=TESTInternetMVC;Integrated Security=True"
         providerName="System.Data.SqlClient" />
  </connectionStrings>

  
    <!-- can also specify known types in the configuration file. This is equivalent to applyingKnownType attribute on the base type, in the sense that it is applicable globally-->
    <!--<system.runtime.serialization>
  <dataContractSerializer>
    <declaredTypes>
      <add type="WCFReportingservice.WCFEmployee, WCFReportingservice, Version=1.0.0.0, &#xD;&#xA;            Culture=Neutral, PublicKeyToken=null"
                                                 >
        <knownType type="WCFReportingservice.FulltimeEmployee, WCFReportingservice, &#xD;&#xA;                    Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null"
                                                                          />
        <knownType type="WCFReportingservice.ParttimeEmployee, WCFReportingservice, &#xD;&#xA;                    Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null"
                                                                          />
      </add>
    </declaredTypes>
  </dataContractSerializer>
</system.runtime.serialization>--> 


<!--C:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools
SVCTRACEVIEWER.EXE TOOL LOCATION-->


</configuration>

<!--  ========= SOAP faults are in XML format and are platform independent. A typical SOAP fault contains
1. FaultCode
2. FaultReason 
3. Detail elements etc.
The Detail element can be used to include any custom xml. We will discuss more about Detail element in a later video session.
SOAP faults are formatted based on SOAP 1.1 or SOAP 1.2 speficications. SOAP format depends on the binding. BasicHttpBinding uses SOAP 1.1 whereas the other built-in WCF bindings use SOAP 1.2.
For the differences between SOAP 1.1 and 1.2 please refer to the following article.
http://www.w3.org/2003/06/soap11-soap12.html
The differences are not that important from a developer perspective, as WCF formats the messages automatically based on the binding we have used to expose the service.
To view SOAP Fault messages, please enable message logging in WCF. We have discussed enabling message logging in Part 9 of WCF video series.
To view SOAP 1.1 fault message, set binding to basicHttpBinding.-->
